<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fleet Tracker - API Routing System</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .diagram-container {
            width: 100%;
            height: auto;
            margin: 20px 0;
        }
        .description {
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .description h3 {
            margin-top: 0;
            color: #495057;
        }
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .feature-item {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
        }
        .feature-item h4 {
            color: #495057;
            margin-top: 0;
        }
        .code-example {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÄ API Routing System</h1>
        <p class="subtitle">How the ApiRouter automatically switches between online and offline systems based on network status</p>
        
        <div class="description">
            <h3>API Router Overview</h3>
            <p>The ApiRouter serves as the central hub for all data requests in the Fleet Tracker application. It automatically detects network status and routes API calls to either the online system (direct HTTP to backend) or offline system (IndexedDB operations), providing a seamless experience regardless of connectivity.</p>
        </div>

        <div class="diagram-container">
            <div class="mermaid">
flowchart TD
    START[Component Needs Data] --> API_CALL[Call ApiRouter Method]
    
    API_CALL --> NETWORK_CHECK{NetworkManager<br/>Check Status}
    
    NETWORK_CHECK -->|Online| ONLINE_PATH[Online API Path]
    NETWORK_CHECK -->|Offline| OFFLINE_PATH[Offline API Path]
    
    %% Online Path
    ONLINE_PATH --> ONLINE_API[OnlineApi.ts<br/>HTTP Request]
    ONLINE_API --> BACKEND[Backend API Call]
    
    BACKEND --> SUCCESS{API Call<br/>Successful?}
    SUCCESS -->|Yes| CACHE_DECISION{Cache Online<br/>Data Enabled?}
    SUCCESS -->|No| ERROR_HANDLE[Throw Error<br/>No Fallback]
    
    CACHE_DECISION -->|Yes| CACHE_DATA[Cache Response<br/>to IndexedDB]
    CACHE_DECISION -->|No| RETURN_ONLINE[Return Online Data]
    
    CACHE_DATA --> RETURN_ONLINE
    
    %% Offline Path
    OFFLINE_PATH --> OFFLINE_API[OfflineOnlyApi.ts<br/>IndexedDB Query]
    OFFLINE_API --> INDEXEDDB_CHECK{Data Exists<br/>in IndexedDB?}
    
    INDEXEDDB_CHECK -->|Yes| TTL_CHECK{Data Still<br/>Valid TTL?}
    INDEXEDDB_CHECK -->|No| RETURN_EMPTY[Return Empty<br/>or Default Data]
    
    TTL_CHECK -->|Yes| RETURN_CACHED[Return Cached Data<br/>fromCache: true]
    TTL_CHECK -->|No| EXPIRED_DATA[Data Expired<br/>Return Stale or Empty]
    
    %% Sync Queue for Offline Operations
    OFFLINE_API --> MUTATION_CHECK{Is Write<br/>Operation?}
    MUTATION_CHECK -->|Yes| ADD_SYNC[Add to Sync Queue<br/>for Later Processing]
    MUTATION_CHECK -->|No| INDEXEDDB_CHECK
    
    ADD_SYNC --> RETURN_SUCCESS[Return Success<br/>Queued for Sync]
    
    %% Network Status Change
    NETWORK_STATUS[Network Status Change] --> SYNC_TRIGGER{Connection<br/>Restored?}
    SYNC_TRIGGER -->|Yes| BG_SYNC[BackgroundSync.ts<br/>Process Queue]
    SYNC_TRIGGER -->|No| CONTINUE[Continue Current Mode]
    
    BG_SYNC --> PROCESS_QUEUE[Process Sync Queue<br/>with Online API]
    PROCESS_QUEUE --> RECONCILE[Reconcile Local<br/>and Remote Data]
    
    %% Return Points
    RETURN_ONLINE --> COMPONENT[Component Receives Data]
    RETURN_CACHED --> COMPONENT
    RETURN_EMPTY --> COMPONENT
    RETURN_SUCCESS --> COMPONENT
    ERROR_HANDLE --> COMPONENT
    EXPIRED_DATA --> COMPONENT
            </div>
        </div>

        <div class="features">
            <div class="feature-item">
                <h4>üåê Network Detection</h4>
                <p><strong>Continuous Monitoring</strong>: NetworkManager runs periodic connectivity tests</p>
                <p><strong>Multiple Checks</strong>: Tests browser navigator.onLine + actual backend ping</p>
                <p><strong>Event Driven</strong>: Components subscribe to network status changes</p>
            </div>
            
            <div class="feature-item">
                <h4>üì± Online Mode Operations</h4>
                <div class="code-example">
                    // ApiRouter automatically routes to OnlineApi<br/>
                    const result = await apiRouter.getVehicles();<br/>
                    // ‚Üí OnlineApi.getVehicles() ‚Üí HTTP call to backend<br/>
                    // ‚Üí Optional caching for offline use
                </div>
            </div>
            
            <div class="feature-item">
                <h4>üì¥ Offline Mode Operations</h4>
                <div class="code-example">
                    // Same interface, different implementation<br/>
                    const result = await apiRouter.getVehicles();<br/>
                    // ‚Üí OfflineOnlyApi.getVehicles() ‚Üí IndexedDB query<br/>
                    // ‚Üí Write operations queued for sync
                </div>
            </div>
            
            <div class="feature-item">
                <h4>üîÑ Background Sync Process</h4>
                <p><strong>Trigger Events</strong>: Network reconnection, app visibility, manual trigger</p>
                <p><strong>Priority Queue</strong>: High priority (trips) ‚Üí Medium ‚Üí Low priority operations</p>
                <p><strong>Retry Logic</strong>: Exponential backoff for failed sync attempts</p>
                <p><strong>Conflict Resolution</strong>: Server data takes precedence, local data reconciled</p>
            </div>
            
            <div class="feature-item">
                <h4>üíæ Cache Management</h4>
                <p><strong>TTL System</strong>: Different cache lifetimes per data type</p>
                <p><strong>Smart Invalidation</strong>: Related cache cleared on data changes</p>
                <p><strong>Storage Monitoring</strong>: Track IndexedDB usage and cleanup expired data</p>
            </div>
            
            <div class="feature-item">
                <h4>üöó Vehicle Status Optimization</h4>
                <p><strong>Separate TTL</strong>: Vehicle status cached for 5 minutes vs 30 minutes for data</p>
                <p><strong>Quick Updates</strong>: Lightweight status-only refreshes when needed</p>
                <p><strong>Batch Operations</strong>: Multiple vehicle status updates in single call</p>
            </div>
        </div>

        <div class="description">
            <h3>üéØ Key Benefits</h3>
            <ul>
                <li><strong>üîÑ Seamless Switching</strong>: Components use same interface regardless of network status</li>
                <li><strong>‚ö° Performance</strong>: Cached data serves instantly, online data cached for offline use</li>
                <li><strong>üõ°Ô∏è Independence</strong>: Offline system failures don't impact online functionality</li>
                <li><strong>üîÑ Auto-Sync</strong>: Offline operations automatically sync when connection returns</li>
                <li><strong>üìä Transparency</strong>: Components know if data is from cache or network</li>
            </ul>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html> 